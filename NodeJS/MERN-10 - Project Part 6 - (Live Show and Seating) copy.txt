Ques-1 --> (Node_express_note_taking)

# Problem Description - 
    You're tasked with developing a backend service for a simple note-taking application. The service should allow users to perform CRUD (Create, Read, Update, Delete) operations on notes. Notes should be stored in a MongoDB database, and the backend should be built using Express and middleware for handling request and response data. Below are the requirements:

Create a Note
    Users should be able to create a new note by sending a POST request to /notes. The request body should contain a JSON object with title and content fields. Validate that both fields are present and not empty.
    Status Codes:
    201 Created: When a note is successfully created.
    400 Bad Request: If the title or content is missing.
    Read Notes
    Users should be able to get a list of all notes by sending a GET request to /notes. Each note should include its id, title, and content.
    Status Code:
    200 OK: When the list of notes is successfully retrieved.
    Update a Note
    Users should be able to update an existing note by sending a PUT request to /notes/:id. The request should include a JSON object with the fields that need to be updated (title and/or content).
    Status Codes:
    200 OK: When the note is successfully updated.
    400 Bad Request: If the title or content is missing or invalid.
    404 Not Found: If the note with the specified id is not found.
    Delete a Note
    Users should be able to delete a note by sending a DELETE request to /notes/:id.
    Status Codes:
    200 OK: When the note is successfully deleted.
    404 Not Found: If the note with the specified id is not found.
    Error Handling
    You must implement error-handling middleware to manage cases where the request contains invalid data or references a non-existent note. Return appropriate HTTP response codes.
    Status Codes:
    400 Bad Request: For validation errors.
    404 Not Found: When a resource is not found.
    500 Internal Server Error: For unhandled server errors.
    Possible Approach
    Defining Routes
    Implement routes for each CRUD operation. Ensure proper validation for request bodies and parameters.

    Middleware for Error Handling
    Create middleware to handle and log errors, and send appropriate HTTP response codes to the client.

    MongoDB Integration
    Use Mongoose's methods to perform CRUD operations on the database.

    Write your code in src/api.js



# Solution - 
    const express = require("express");
    const mongoose = require("mongoose");
    const bodyParser = require("body-parser");

    // Initialize Express app
    const app = express();
    app.use(bodyParser.json());

    /** Do not change the connection string below */
    mongoose.connect("mongodb://localhost:27017/myApp", {
    useNewUrlParser: true,
    useUnifiedTopology: true,
    });
    /** connection ends */

    // Define Note schema and model
    const noteSchema = new mongoose.Schema({
    title: { type: String, required: true },
    content: { type: String, required: true },
    });

    const Note = mongoose.model("Note", noteSchema);

    // Routes
    // TODO: Implement CRUD routes
    app.post("/notes", async (req, res, next) => {
    try {
        const { title, content } = req.body;

        // Validate request body
        if (!title || !content) {
        return res.status(400).json({ error: "Title and content are required." });
        }

        // Create a new note
        const note = new Note({ title, content });
        await note.save();

        res.status(201).json(note);
    } catch (err) {
        next(err);
    }
    });

    // Read all Notes
    app.get("/notes", async (req, res, next) => {
    try {
        const notes = await Note.find({}, "_id title content");
        res.status(200).json(notes);
    } catch (err) {
        next(err);
    }
    });

    // Update a Note
    app.put("/notes/:id", async (req, res, next) => {
    try {
        const { id } = req.params;
        const { title, content } = req.body;

        // Validate request body
        if (!title && !content) {
        return res.status(400).json({ error: "At least one of title or content must be provided." });
        }

        // Find and update the note
        const note = await Note.findById(id);
        if (!note) {
        return res.status(404).json({ error: "Note not found." });
        }

        if (title) note.title = title;
        if (content) note.content = content;
        await note.save();

        res.status(200).json(note);
    } catch (err) {
        next(err);
    }
    });

    // Delete a Note
    app.delete("/notes/:id", async (req, res) => {
    try {
        const note = await Note.findByIdAndDelete(req.params.id);
        if (!note) {
        return res.status(404).json({ message: "Note not found" });
        }
        res.status(200).json({ message: "Note deleted successfully" }); // Updated message
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
    });

    // Error Handling Middleware
    app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(200).send({ error: err.message });
    });

    module.exports = { app, Note };

Ques-2 --> (Node_express_library_management)

# Problem Description - 
    You are tasked with developing a RESTful API for managing an online library system. This system will use the Express framework, MongoDB Atlas for storage, and will involve comprehensive data modeling for books and authors. The solution should cover the following requirements:

    Data Models:
    Book: Define a Book model with fields title (String), author (ObjectId, referencing Author), year (Number), and genre (String).
    Author: Define an Author model with fields name (String), birthdate (Date), and bio (String).
    Relationships: Each Book should reference an Author via an ObjectId.
    Routes and Endpoints:
    GET /books:
    Fetch a list of all books, optionally filtering by genre.

    Status Code:
    200 OK: Successfully retrieved the list of books.
    401 Unauthorized: If the API key is missing or invalid.
    POST /books:
    Add a new book to the database. The request body should contain title, author (ID), year, and genre.

    Status Codes:
    201 Created: Successfully added the new book.
    400 Bad Request: If required fields are missing or invalid.
    401 Unauthorized: If the API key is missing or invalid.
    GET /books/:id:
    Fetch a single book by its ID, including its author's details.

    Status Codes:
    200 OK: Successfully retrieved the book and author details.
    404 Not Found: If the book with the specified ID is not found.
    401 Unauthorized: If the API key is missing or invalid.
    PUT /books/:id:
    Update a book by its ID. The request body can contain any combination of title, author, year, or genre.

    Status Codes:
    200 OK: Successfully updated the book.
    400 Bad Request: If required fields are missing or invalid.
    404 Not Found: If the book with the specified ID is not found.
    401 Unauthorized: If the API key is missing or invalid.
    DELETE /books/:id:
    Delete a book by its ID.

    Status Codes:
    200 Book deleted successfully: Successfully deleted the book.
    404 Not Found: If the book with the specified ID is not found.
    401 Unauthorized: If the API key is missing or invalid.
    GET /authors:
    Fetch a list of all authors.

    Status Code:
    200 OK: Successfully retrieved the list of authors.
    401 Unauthorized: If the API key is missing or invalid.
    POST /authors:
    Add a new author to the database. The request body should contain name, birthdate, and bio.

    Status Codes:
    201 Created: Successfully added the new author.
    400 Bad Request: If required fields are missing or invalid.
    401 Unauthorized: If the API key is missing or invalid.
    GET /authors/:id:
    Fetch a single author by their ID, including all books they've authored.

    Status Codes:
    200 OK: Successfully retrieved the author and their books.
    404 Author not found: If the author with the specified ID is not found.
    401 Unauthorized: If the API key is missing or invalid.
    Middleware:
    Authentication:
    Implement an authentication middleware that verifies an API key passed in the Authorization header.

    Status Code:
    401 Unauthorized: If the API key is invalid or missing, respond with this status and a message saying "Unauthorized".
    Error Handling:
    Implement a global error handler to catch any errors and respond with a 500 Internal Server Error status, along with a descriptive message.

    Database:
    MongoDB Atlas: Use MongoDB Atlas for storing the books and authors.
    Possible Approach:
    Database Connection:
    Connect to MongoDB Atlas using Mongoose.

    Data Modeling:

    Book Schema: Defines a book with title, author, year, and genre.
    Author Schema: Defines an author with name, birthdate, and bio.
    Relationships: Book schema references Author via an ObjectId.
    Authentication Middleware:
    Check the API key in the request headers. If valid, allow the request to proceed; otherwise, respond with a 401 Unauthorized. The API key should be "mysecretkey".

    CRUD Routes:
    Define CRUD routes:

    GET /books: Fetches all books, optionally filtering by genre.
    POST /books: Adds a new book to the database.
    GET /books/:id: Fetches a specific book by its ID, including its author's details.
    PUT /books/:id: Updates a book by its ID.
    DELETE /books/:id: Deletes a book by its ID.
    GET /authors: Fetches all authors.
    POST /authors: Adds a new author to the database.
    GET /authors/:id: Fetches a specific author by their ID, including all books they've authored.
    Error Handling:
    Implement a global error handler to handle exceptions gracefully, returning a 500 Internal Server Error status along with an error message.

# Solution - 
    /*********************code to be  written in the stub*************************/
    const express = require("express");
    const mongoose = require("mongoose");
    const bodyParser = require("body-parser");

    const app = express();
    app.use(bodyParser.json());

    /** Do not change the connection string below */
    mongoose.connect("mongodb://localhost:27017/myApp", {
    useNewUrlParser: true,
    useUnifiedTopology: true,
    });

    // Define the Author schema and model
    const authorSchema = new mongoose.Schema({
    name: { type: String, required: true },
    birthdate: { type: Date, required: true },
    bio: { type: String, required: true },
    });
    const Author = mongoose.model("Author", authorSchema);

    // Define the Book schema and model
    const bookSchema = new mongoose.Schema({
    title: { type: String, required: true },
    author: { type: mongoose.Schema.Types.ObjectId, ref: "Author", required: true },
    year: { type: Number, required: true },
    genre: { type: String, required: true },
    });
    const Book = mongoose.model("Book", bookSchema);

    // Middleware for authentication
    function authenticate(req, res, next) {
    const apiKey = req.header("Authorization");
    if (apiKey === "mysecretkey") {
        next();
    } else {
        res.status(401).json({ message: "Unauthorized" });
    }
    }

    // Routes for CRUD operations

    // GET /books
    app.get("/books", authenticate, async (req, res, next) => {
    try {
        const { genre } = req.query;
        const filter = genre ? { genre } : {};
        const books = await Book.find(filter).populate("author");
        res.status(200).json(books);
    } catch (err) {
        next(err);
    }
    });

    // POST /books
    app.post("/books", authenticate, async (req, res, next) => {
    try {
        const { title, author, year, genre } = req.body;
        if (!title || !author || !year || !genre) {
        return res.status(400).json({ message: "All fields are required." });
        }
        const book = new Book({ title, author, year, genre });
        await book.save();
        res.status(201).json(book);
    } catch (err) {
        next(err);
    }
    });

    // GET /books/:id
    app.get("/books/:id", authenticate, async (req, res, next) => {
    try {
        const book = await Book.findById(req.params.id).populate("author");
        if (!book) {
        return res.status(404).json({ message: "Book not found." });
        }
        res.status(200).json(book);
    } catch (err) {
        next(err);
    }
    });

    // PUT /books/:id
    app.put("/books/:id", authenticate, async (req, res, next) => {
    try {
        const updates = req.body;
        const book = await Book.findByIdAndUpdate(req.params.id, updates, { new: true });
        if (!book) {
        return res.status(404).json({ message: "Book not found." });
        }
        res.status(200).json(book);
    } catch (err) {
        next(err);
    }
    });

    // DELETE /books/:id
    app.delete("/books/:id", authenticate, async (req, res, next) => {
    try {
        const book = await Book.findByIdAndDelete(req.params.id);
        if (!book) {
        return res.status(404).json({ message: "Book not found." });
        }
        res.status(200).json({ message: "Book deleted successfully." });
    } catch (err) {
        next(err);
    }
    });

    // GET /authors
    app.get("/authors", authenticate, async (req, res, next) => {
    try {
        const authors = await Author.find();
        res.status(200).json(authors);
    } catch (err) {
        next(err);
    }
    });

    // POST /authors
    app.post("/authors", authenticate, async (req, res, next) => {
    try {
        const { name, birthdate, bio } = req.body;
        if (!name || !birthdate || !bio) {
        return res.status(400).json({ message: "All fields are required." });
        }
        const author = new Author({ name, birthdate, bio });
        await author.save();
        res.status(201).json(author);
    } catch (err) {
        next(err);
    }
    });

    // GET /authors/:id
    app.get("/authors/:id", authenticate, async (req, res, next) => {
    try {
        const author = await Author.findById(req.params.id);
        if (!author) {
        return res.status(404).json({ message: "Author not found." });
        }
        const books = await Book.find({ author: author._id });
        res.status(200).json({ author, books });
    } catch (err) {
        next(err);
    }
    });

    // Global error handler
    app.use((err, req, res, next) => {
    res.status(500).json({ message: err.message });
    });

    module.exports = { app, Author, Book };